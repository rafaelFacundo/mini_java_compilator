PARSER_BEGIN(MyParser)

public class MyParser {
    public static void main(String[] args) throws ParseException, TokenMgrError{
    try {
        java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
        new MyParser(file).Program();
        System.out.println("Success");
    } catch(Exception e) {
        System.out.println(e);
        System.out.println("Failed");
    }
    }
}

PARSER_END(MyParser)

TOKEN : {
    < INT: "int" >
    | < BOOLEAN: ("boolean") >
    | < IF: ("if") >
    | < ELSE: ("else") >
    | < WHILE: ("while") >
    | < TRUE: ("true") >
    | < FALSE: ("false") >
    | < THIS: ("this") >
    | < NEW: ("new") >
    | < PLUS: ("+") >
    | < MINUS: ("-") >
    | < MULT: ("*") >
    | < LOGIC_AND: ("&&") >
    | < LOGIC_NOT: ("!") >
    | < SMALLER: ("<") >
    | < EQUAL: ("=") >
    | < LENGTH: ("length") >
    | < SYSTEM_OUT_PRINTLN: ("System.out.println") >
    | < PUBLIC: ("public") >
    | < STATIC: ("static") >
    | < VOID: ("void") >
    | < MAIN: ("main") >
    | < STRING: ("String") >
    | < CLASS: ("class") >
    | < EXTENDS: ("extends") >
    | < RETURN: ("return") >
    | < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*>
    | < #LETTER: ["a"-"z", "A"-"Z"] >
    | < #DIGIT: ["0"-"9"]>
    | < INTEGER_LITERAL: (["0"-"9"])+ >
}

TOKEN: {
    <DOT: ".">
    | <COMMA: ",">
    | <SCOLON: ";">
    | <LPAR: "(">
    | <RPAR: ")">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <LBRACE: "{">
    | <RBRACE: "}">
}

SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n"])*>
    | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

void Program():
{}
{
    MainClass() (ClassDecl())*
}

void MainClass():
{}
{
    <CLASS> <IDENTIFIER> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
    <LPAR> <STRING> <LBRACKET> <RBRACKET> <IDENTIFIER> <RPAR> <LBRACE>
    Statement() <RBRACE> <RBRACE>
}

void ClassDecl():
{}
{
    LOOKAHEAD(3)
    <CLASS> <IDENTIFIER> <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE>
    | 
    <CLASS> <IDENTIFIER> <EXTENDS> <IDENTIFIER> <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE> 
}

void VarDeclaration():
{}
{
    Type() <IDENTIFIER> <SCOLON>
}

void MethodDeclaration():
{}
{
    <PUBLIC> Type() <IDENTIFIER> <LPAR> FormalList() <RPAR> <LBRACE> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SCOLON> <RBRACE>
}

void FormalList():
{}
{
    Type() <IDENTIFIER> (FormalRest())*
    | Empty()
}

void FormalRest():
{}
{
    <COMMA> Type() <IDENTIFIER>
}

void Type():
{}
{
    LOOKAHEAD(2)
    <INT> <LBRACKET> <RBRACKET> 
    | <BOOLEAN>
    | <INT>
    | <IDENTIFIER>
}

void Statement():
{}
{
    LOOKAHEAD(2)
    <LBRACE> (Statement())* <RBRACE>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR>  Expression() <RPAR> Statement() 
    | <SYSTEM_OUT_PRINTLN> <LPAR> Expression() <RPAR> <SCOLON>
    | LOOKAHEAD(2) <IDENTIFIER> <EQUAL> Expression() <SCOLON>
    | LOOKAHEAD(2) <IDENTIFIER> <LBRACKET> Expression() <RBRACKET> <EQUAL> Expression() <SCOLON>
}

void Empty():
{}
{
    {}
}

void Expression_prime():
{}
{
    LOOKAHEAD(3)
    <LOGIC_AND> LetT() Expression_prime()
    | <SMALLER> LetT() Expression_prime()
    | <PLUS> LetT() Expression_prime()
    | <MINUS> LetT() Expression_prime()
    | <MULT> LetT() Expression_prime()
    | <LBRACKET> Expression() <RBRACKET> Expression_prime()
    | LOOKAHEAD(2) <DOT> <LENGTH> Expression_prime()
    | LOOKAHEAD(2) <DOT> <IDENTIFIER> <LPAR> ExpressionList() <RPAR> Expression_prime()
    | Empty()
}

void LetTL():
{}
{
    <MULT> LetF() LetTL()
    | <LOGIC_AND> LetF() LetTL()
    | Empty()

}

void LetT():
{}
{
    LetF() LetTL()
}

void Expression():
{}
{
    LetT() Expression_prime()
    | LOOKAHEAD(2) <NEW> <INT> <LBRACKET> Expression() <RBRACKET> Expression_prime()
    | LOOKAHEAD(2) <NEW> <IDENTIFIER> <LPAR> <RPAR> Expression_prime()
}

void LetF():
{}
{
    <INTEGER_LITERAL>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | <LOGIC_NOT> Expression()
    | <LPAR> Expression() <RPAR>
}


void ExpressionList():
{}
{
    Expression() (ExpressionRest())*
    | Empty()
}

void ExpressionRest():
{}
{
    <COMMA> Expression()
}
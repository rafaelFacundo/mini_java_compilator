PARSER_BEGIN(MyParser)

public class MyParser {
    public static void main(String[] args) throws ParseException, TokenMgrError{
    try {
        java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
        new MyParser(file).Program();
        System.out.println("Success");
    } catch(Exception e) {
        System.out.println(e);
        System.out.println("Failed");
    }
    }
}

PARSER_END(MyParser)

TOKEN : {
    < INT: "int" >
    | < BOOLEAN: ("boolean") >
    | < IF: ("if") >
    | < ELSE: ("else") >
    | < WHILE: ("while") >
    | < TRUE: ("true") >
    | < FALSE: ("false") >
    | < THIS: ("this") >
    | < NEW: ("new") >
    | < PLUS: ("+") >
    | < MINUS: ("-") >
    | < MULT: ("*") >
    | < LOGIC_AND: ("&&") >
    | < LOGIC_NOT: ("!") >
    | < SMALLER: ("<") >
    | < EQUAL: ("=") >
    | < LENGTH: ("length") >
    | < SYSTEM_OUT_PRINTLN: ("System.out.println") >
    | < PUBLIC: ("public") >
    | < STATIC: ("static") >
    | < VOID: ("void") >
    | < MAIN: ("main") >
    | < STRING: ("String") >
    | < CLASS: ("class") >
    | < EXTENDS: ("extends") >
    | < RETURN: ("return") >
    | < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*>
    | < #LETTER: ["a"-"z", "A"-"Z"] >
    | < #DIGIT: ["0"-"9"]>
    | < INTEGER_LITERAL: (["0"-"9"])+ >
}

TOKEN: {
    <DOT: ".">
    | <COMMA: ",">
    | <SCOLON: ";">
    | <LPAR: "(">
    | <RPAR: ")">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <LBRACE: "{">
    | <RBRACE: "}">
}

SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n"])*>
    | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

void Program():
{}
{
    MainClass() (ClassDecl())*
}

void MainClass():
{}
{
    <CLASS> <IDENTIFIER> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
    <LPAR> <STRING> <LBRACKET> <RBRACKET> <IDENTIFIER> <RPAR> <LBRACE>
    Statement() <RBRACE> <RBRACE>
}

void ClassDecl():
{}
{
    LOOKAHEAD(3)
    <CLASS> <IDENTIFIER> <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE>
    | 
    <CLASS> <IDENTIFIER> <EXTENDS> <IDENTIFIER> <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE> 
}

void VarDeclaration():
{}
{
    Type() <IDENTIFIER> <SCOLON>
}

void MethodDeclaration():
{}
{
    <PUBLIC> Type() <IDENTIFIER> <LPAR> FormalList() <RPAR> <LBRACE> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SCOLON> <RBRACE>
}

void FormalList():
{}
{
    Type() <IDENTIFIER> (FormalRest())*
    | Empty()
}

void FormalRest():
{}
{
    <COMMA> Type() <IDENTIFIER>
}

void Type():
{}
{
    LOOKAHEAD(2)
    <INT> <LBRACKET> <RBRACKET> 
    | <BOOLEAN>
    | <INT>
    | <IDENTIFIER>
}

void Statement():
{}
{
    LOOKAHEAD(2)
    <LBRACE> (Statement())* <RBRACE>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR>  Expression() <RPAR> Statement() 
    | <SYSTEM_OUT_PRINTLN> <LPAR> Expression() <RPAR> <SCOLON>
    | LOOKAHEAD(2) <IDENTIFIER> <EQUAL> Expression() <SCOLON>
    | LOOKAHEAD(2) <IDENTIFIER> <LBRACKET> Expression() <RBRACKET> <EQUAL> Expression() <SCOLON>
}

void Empty():
{}
{
    {}
}

void Expression_prime():
{}
{
    LOOKAHEAD(3)
    <LOGIC_AND> LetT() Expression_prime()
    | <SMALLER> LetT() Expression_prime()
    | <PLUS> LetT() Expression_prime()
    | <MINUS> LetT() Expression_prime()
    | <MULT> LetT() Expression_prime()
    | <LBRACKET> Expression() <RBRACKET> Expression_prime()
    | LOOKAHEAD(2) <DOT> <LENGTH> Expression_prime()
    | LOOKAHEAD(2) <DOT> <IDENTIFIER> <LPAR> ExpressionList() <RPAR> Expression_prime()
    | Empty()
}

void LetTL():
{}
{
    <MULT> LetF() LetTL()
    | <LOGIC_AND> LetF() LetTL()
    | Empty()

}

void LetT():
{}
{
    LetF() LetTL()
}

void Expression():
{}
{
    LetT() Expression_prime()
    | LOOKAHEAD(2) <NEW> <INT> <LBRACKET> Expression() <RBRACKET> Expression_prime()
    | LOOKAHEAD(2) <NEW> <IDENTIFIER> <LPAR> <RPAR> Expression_prime()
}

void LetF():
{}
{
    <INTEGER_LITERAL>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | <LOGIC_NOT> Expression()
    | <LPAR> Expression() <RPAR>
}


void ExpressionList():
{}
{
    Expression() (ExpressionRest())*
    | Empty()
}

void ExpressionRest():
{}
{
    <COMMA> Expression()
}



Exp Start():
    {Exp e;}
    {e=Exp() {return e;}}

Exp Exp():
    {Exp e1, e2;}
    {
        e1=Term()
        (
            "+" e2=Term() {e1=new PlusExp(e1,e2);} |
            "-" e2=Term() {e1=new MinusExp(e1,e2);}
        )*
        {return e1}
    }

Exp Term():
    {Exp e1, e2;}
    {
        e1=Factor()
        (
            "*" e2=Factor() {e1=new TimesExp(e1,e2);} |
            "/" e2=Factor() {e1=new DivideExp(e1,e2);}
        )*
        {return e1}
    }

Exp Factor():
    {Token t; Exp e;}
    {
        (
            t=<IDENTIFIER>      {return new Identifier(t.image);}       |
            t=<INTEGER_LITERAL> {return new IntegerLiteral(t.image);}   |
            "(" e=Exp() ")"     {return e}
        )
    }




public interface Visitor {
    public int visit(PlusExp n);
    public int visit(MinusExp n);
    public int visit(TimesExp n);
    public int visit(DivideExp n);
    public int visit(Identifier n);
    public int visit(IntegerLiteral n);
}

public class Interpreter implements Visitor {
    public int visit(PlusExp n) {
        return n.e1.accept(this) + n.e2.accept(this);
    }

    public int visit(MinusExp n) {
        return n.e1.accept(this) - n.e2.accept(this);
    }

    public int visit(TimesExp n) {
        return n.e1.accept(this) * n.e2.accept(this);
    }

    public int visit(DivideExp n) {
        return n.e1.accept(this) / n.e2.accept(this);
    }

    public int visit(Identifier n) {
        return lookup(n.f0);
    }

    public int visit(IntegerLiteral n) {
        return Integer.parseInt(n.f0);
    }

}


public abstract class Exp {
    public abstract int accept(Visitor v);
}

public class PlusExp extends Exp {
    public Exp e1, e2;

    public PlusExp(Exp a1, Exp a2) {
         e1=a1;
         e2=a2;
    }

    public int accept(Visitor v) {
        return v.visit(this);
    }
}

public class MinusExp extends Exp {
    public Exp e1, e2;

    public MinusExp(Exp a1, Exp a2) {
         e1=a1;
         e2=a2;
    }

    public int accept(Visitor v) {
        return v.visit(this);
    }
}

public class TimesExp extends Exp {
    public Exp e1, e2;

    public TimesExp(Exp a1, Exp a2) {
         e1=a1;
         e2=a2;
    }

    public int accept(Visitor v) {
        return v.visit(this);
    }
}

public class DivideExp extends Exp {
    public Exp e1, e2;

    public DivideExp(Exp a1, Exp a2) {
         e1=a1;
         e2=a2;
    }

    public int accept(Visitor v) {
        return v.visit(this);
    }
}

public class Identifier extends Exp {
    public String f0;

    public Identifier(String n0) {
        f0=n0;
    }

    public int accept(Visitor v) {
        return v.visit(this);
    }
}

public class IntegerLiteral extends Exp {
    public String f0;

    public IntegerLiteral(String n0) {
        f0=n0;
    }

    public int accept(Visitor v) {
        return v.visit(this);
    }
}


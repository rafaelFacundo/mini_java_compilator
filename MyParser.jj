PARSER_BEGIN(MyParser)

public class MyParser {
    public static void main(String[] args) throws ParseException {
        MyParser lexer = new MyParser(System.in);
        Token token;
        try {
            while ((token = lexer.getNextToken()).kind != 0) {
                System.out.println(token.image);
            }
        } catch (TokenMgrError e) {
            System.err.println("Error analyzing input: " + e.getMessage());
        }
    }
}

PARSER_END(MyParser)

TOKEN : {
    < INT: "int" >
    | < BOOLEAN: (["0"-"1"])+ >
    | < IF: ("if") >
    | < ELSE: ("else") >
    | < WHILE: ("while") >
    | < TRUE: ("true") >
    | < FALSE: ("false") >
    | < THIS: ("this") >
    | < NEW: ("new") >
    | < PLUS: ("+") >
    | < MINUS: ("-") >
    | < MULT: ("*") >
    | < LOGIC_AND: ("&&") >
    | < LOGIC_NOT: ("!") >
    | < SMALLER: ("<") >
    | < EQUAL: ("=") >
    | < LENGHT: ("lenght") >
    | < SYSTEM_OUT_PRINTLN: ("System.out.println") >
    | < PUBLIC: ("public") >
    | < STATIC: ("static") >
    | < VOID: ("void") >
    | < MAIN: ("main") >
    | < STRING: ("String") >
    | < CLASS: ("class") >
    | < EXTENDS: ("extends") >
    | < RETURN: ("return") >
    | < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*>
    | < #LETTER: ["a"-"z", "A"-"Z"] >
    | < #DIGIT: ["0"-"9"]>
    | < INTEGER_LITERAL: (["0"-"9"])+ >
}

TOKEN: {
    <DOT: ".">
    | <COMMA: ",">
    | <SCOLON: ";">
    | <LPAR: "(">
    | <RPAR: ")">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <LBRACE: "{">
    | <RBRACE: "}">
}

SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n"])*>
    | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

void Program():
{}
{
    MainClass() (ClassDecl())*
}

void MainClass():
{}
{
    <CLASS> <IDENTIFIER> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
    <LPAR> <STRING> <LBRACKET> <RBRACKET> <IDENTIFIER> <RPAR> <LBRACE>
    Statement() <RBRACE> <RBRACE>
}

void ClassDecl():
{}
{
    LOOKAHEAD(3)
    <CLASS> <IDENTIFIER> <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE>
    | 
    <CLASS> <IDENTIFIER> <EXTENDS> <IDENTIFIER> <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE> 
}

void VarDeclaration():
{}
{
    Type() <IDENTIFIER> <SCOLON>
}

void MethodDeclaration():
{}
{
    <PUBLIC> Type() <IDENTIFIER> <LPAR> FormalList() <RPAR> <LBRACE> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SCOLON> <RBRACE>
}

void FormalList():
{}
{
    Type() <IDENTIFIER> (FormalRest())*
    | Empty()
}

void FormalRest():
{}
{
    <COMMA> Type() <IDENTIFIER>
}

void Type():
{}
{
    LOOKAHEAD(2)
    <INT> <RBRACKET> <LBRACKET> 
    | <BOOLEAN>
    | <INT>
    | <IDENTIFIER>
}

void Statement():
{}
{
    LOOKAHEAD(2)
    <LBRACE> (Statement())* <RBRACE>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR>  Expression() <RPAR> Statement() 
    | <SYSTEM_OUT_PRINTLN> <LPAR> Expression() <RPAR> <SCOLON>
    | LOOKAHEAD(2) <IDENTIFIER> <EQUAL> Expression() <SCOLON>
    | LOOKAHEAD(2) <IDENTIFIER> <LBRACKET> Expression() <RBRACKET> <EQUAL> Expression() <SCOLON>
}

void Empty():
{}
{
    {}
}

void Expression_prime():
{}
{
    LOOKAHEAD(3)
    <LOGIC_AND> Expression_prime()
    | <SMALLER> Expression_prime()
    | <PLUS> Expression_prime()
    | <MINUS> Expression_prime()
    | <MULT> Expression_prime()
    | <LBRACKET> Expression() <RBRACKET> Expression_prime()
    | LOOKAHEAD(2) <DOT> <LENGHT> Expression_prime()
    | LOOKAHEAD(2) <DOT> <IDENTIFIER> <LPAR> ExpressionList() <RPAR> 
    | Empty()
}

void Expression():
{}
{
    
    <TRUE> Expression_prime()
    | <FALSE> Expression_prime()
    | <IDENTIFIER> Expression_prime()
    | <THIS> Expression_prime()
    | <INTEGER_LITERAL> Expression_prime()
    | LOOKAHEAD(2) <NEW> <INT> <LBRACKET> Expression() <RBRACKET> Expression_prime()
    | LOOKAHEAD(2) <NEW> <IDENTIFIER> <LPAR> <RPAR> Expression_prime()
    | <LOGIC_NOT> Expression() 
    | <LPAR> Expression() <RPAR> Expression_prime()
}

void ExpressionList():
{}
{
    Expression() (ExpressionRest())*
    | Empty()
}

void ExpressionRest():
{}
{
    <COMMA> Expression()
}